#include "CPP_OPTIONS.h"

C     !ROUTINE: GET_FROZEN_MASS_SURF
C     !INTERFACE:
         
      SUBROUTINE GET_FROZEN_MASS_SURF(myThid,myTime)
          
C     !DESCRIPTION:
C     *==========================================================*
C     | SUBROUTINE GET_FROZEN_MASS_SURF
C     ! ***********THIS NEEDS TO BE MERGED WITH STEP_SURFACE_T.F***
C     | o First, calculate surface temperature, then condense of
C     |  sublimate surface frost if necessary
C     |  units: kg/s
C     |  author: amz
C     *==========================================================*
            
      IMPLICIT NONE
     
C     == Global variables
#include "SIZE.h"
#include "EEPARAMS.h"
#include "PARAMS.h"
#include "DYNVARS.h"
#include "GRID.h"
#include "AMZVARS.h"
#include "SURFACE.h"
#include "FFIELDS.h"
            
C     !INPUT/OUTPUT PARAMETERS:
C     == Routine arguments ==
      INTEGER myThid
      _RL myTime
              
C     !LOCAL VARIABLES:
C     Local variables
C     i,j,k,bi,bj       :: Loop counters
      INTEGER i, j, k, bi, bj,ks
      _RL tfrostamz,termP,massneeded,tau
      _RL atmdownwardflux,termPAtkSurfC,tauAtkSurfC
      _RL lssol,qo,tfrostsurf,temp1,rho

C     Begin equations

C First need Ls for Qo calculation below

      IF (lsIsConstant .EQ. 0) THEN
       CALL GET_LS(myTime,lssol)
      ELSE
       lssol = lsperpetual
      ENDIF
               
#ifdef ALLOW_ADDFLUID
      IF(selectAddFluid.NE.0) THEN
       DO bj=myByLo(myThid),myByHi(myThid)
        DO bi=myBxLo(myThid),myBxHi(myThid)
         DO j = 1,sNy
          DO i = 1,sNx
           tfrostsurf=1./(1./referenceTempInFrostEqn - 
     &                    atm_Rd/atm_L*LOG((Ro_surf(i,j,bi,bj)+
     &                  etaN(i,j,bi,bj))/referencePresInFrostEqn))
           ks=kSurfC(i,j,bi,bj)
           IF(surfaceT(i,j,bi,bj).LT.tfrostsurf) THEN
            termP=rC(ks)*(Ro_surf(i,j,bi,bj)+etaN(i,j,bi,bj))
     &         /Ro_surf(i,j,bi,bj)
            temp1=theta(i,j,ks,bi,bj)*(termP/atm_po)**atm_kappa
            rho=termP/atm_Rd/temp1
            addMass(i,j,ks,bi,bj)=addMass(i,j,ks,bi,bj)+
     &            rho*rA(i,j,bi,bj)/atm_L*drF(ks)*
     &            hfacC(i,j,ks,bi,bj)*atm_cp/deltaT*
     &            (surfaceT(i,j,bi,bj)-tfrostsurf)
            massonground(i,j,bi,bj)=massonground(i,j,bi,bj)
     &                              -addMass(i,j,ks,bi,bj)
            albedoany(i,j,bi,bj)=albedoice
            emissivity(i,j,bi,bj)=emissivityOfIce
            surfaceTPrime(i,j,bi,bj)=tfrostsurf
           ELSEIF(massonground(i,j,bi,bj) .GT. 0.) THEN
            termP=rC(ks)*(Ro_surf(i,j,bi,bj)+etaN(i,j,bi,bj))
     &        /Ro_surf(i,j,bi,bj)
            temp1=theta(i,j,ks,bi,bj)*(termP/atm_po)**atm_kappa
            rho=termP/atm_Rd/temp1
            massneeded=
     &            rho*rA(i,j,bi,bj)/atm_L*drF(ks)*
     &            hfacC(i,j,ks,bi,bj)*atm_cp/deltaT*
     &            (surfaceT(i,j,bi,bj)-tfrostsurf)
            IF(massneeded.LT.massonground(i,j,bi,bj)) THEN
             addMass(i,j,ks,bi,bj)=
     &        addMass(i,j,ks,bi,bj)+massneeded
             massonground(i,j,bi,bj)=
     &        massonground(i,j,bi,bj)-massneeded
             surfaceTPrime(i,j,bi,bj)=tfrostsurf
             useSurfaceTflag(i,j,bi,bj)=1.
            ELSE
             addMass(i,j,ks,bi,bj)=
     &        addMass(i,j,ks,bi,bj)+massonground(i,j,bi,bj)
             termP=rC(ks)*(Ro_surf(i,j,bi,bj)+etaN(i,j,bi,bj))
     &         /Ro_surf(i,j,bi,bj)
             temp1=theta(i,j,ks,bi,bj)*(termP/atm_po)**atm_kappa
             rho=termP/atm_Rd/temp1
             surfaceTPrime(i,j,bi,bj)=surfaceT(i,j,bi,bj)+
     &        atm_L*massonground(i,j,bi,bj)/rho/
     &        rA(i,j,bi,bj)/atm_cp*deltaT/
     &        drF(ks)/hfacC(i,j,ks,bi,bj)
             ENDIF
             albedoany(i,j,bi,bj)=albedoland
             emissivity(i,j,bi,bj)=emissivityOfLand
            ENDIF
           ELSE
            useSurfaceTflag(i,j,bi,bj)=0.
            surfaceTPrime(i,j,bi,bj)=surfaceT(i,j,bi,bj)
           ENDIF
          ENDDO
         ENDDO
        ENDDO
       ENDDO
      ENDIF
#endif
               
               
      RETURN
      END
